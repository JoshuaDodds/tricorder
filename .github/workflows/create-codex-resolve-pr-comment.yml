name: Tell @codex to fix merge conflict
on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to run on (do NOT use 'main')"
        required: true
      pr_number:
        description: "Optional: PR number (auto-detect if omitted)"
        required: false
      max_inline_size:
        description: "Max file size (bytes) to inline in comment (fallback to gist if larger)"
        required: false
        default: "60000"

permissions:
  contents: read
  issues: write

jobs:
  post-conflicts:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.branch != 'main' && github.event.inputs.branch != '' }}
    env:
      GITHUB_API: https://api.github.com
      REPO: ${{ github.repository }}
    steps:
      - name: Checkout target branch (full history)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
          fetch-depth: 0

      - name: Configure git user
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Fetch remote default refs (main/master)
        run: |
          # Try common default branch names
          git fetch origin main || true
          git fetch origin master || true
          # show current refs (debug)
          git show-ref --head || true
          git branch -a || true

      - name: Attempt merge (no commit) to reproduce conflicts
        id: attempt_merge
        run: |
          set -e
          # Prefer origin/main, fallback to origin/master, fallback to FETCH_HEAD
          if git rev-parse --verify --quiet refs/remotes/origin/main >/dev/null; then
            git merge --no-commit --no-ff origin/main || true
          elif git rev-parse --verify --quiet refs/remotes/origin/master >/dev/null; then
            git merge --no-commit --no-ff origin/master || true
          else
            git merge --no-commit --no-ff FETCH_HEAD || true
          fi

          # detect conflicts
          if git ls-files -u | grep -q .; then
            echo "conflicts=true" >> $GITHUB_OUTPUT
          else
            echo "conflicts=false" >> $GITHUB_OUTPUT
          fi

      - name: Exit if no conflicts
        if: steps.attempt_merge.outputs.conflicts == 'false'
        run: |
          echo "No conflicts after merging remote default into ${{ github.event.inputs.branch }}. Nothing to post."

      - name: Prepare PR comment with conflicted files
        if: steps.attempt_merge.outputs.conflicts == 'true'
        id: prepare
        env:
          BRANCH: ${{ github.event.inputs.branch }}
          MAX_INLINE: ${{ github.event.inputs.max_inline_size }}
          REPO_PAT: ${{ secrets.REPO_PAT }}
        run: |
          set -euo pipefail

          CONFLICT_FILES=$(git ls-files -u | awk '{print $4}' | sort -u)
          echo "Conflicted files: $CONFLICT_FILES" >&2

          # Start building comment
          COMMENT="Automated context: attempted merging the repository default branch into \`${BRANCH}\` produced merge conflicts. Tagging @codex to resolve.\\n\\n"
          COMMENT="$COMMENT---\\n"
          COMMENT="$COMMENT**Resolution instructions for @codex (follow exactly):**\\n\\n"
          COMMENT="$COMMENT\`\`\`text\\n@codex You are resolving a Git merge conflict. I will provide the full file contents including conflict markers (<<<<<<<, =======, >>>>>>>).\\n\\nYour task:\\n    Combine both conflicting changes so that no functionality is lost.\\n    Prefer keeping new code from both branches unless it is clearly redundant or incompatible.\\n    Preserve function signatures, imports, and surrounding context exactly unless they must change for the code to run.\\n    Ensure the final code is syntactically correct and logically consistent.\\n    Do NOT remove new functionality from either branch unless it is duplicated.\\n    Resolve without adding comments, explanations, and be sure to remove conflict markers.\\n\\nAfter producing the resolved file(s), overwrite the conflicted file(s) in the branch, then run (from the repo root):\\n    git add <file> && git commit -m \"chore: AI-resolved merge conflicts (automated)\" && git push origin HEAD\\n\\nYou should push using credentials that can push to this repository as the repository user.\\n\\nEND OF INSTRUCTIONS.\\n\`\`\`\\n\\n"
          COMMENT="$COMMENT---\\n\\n"

          # Add each conflicted file inline or create a private gist if it's too large
          for f in $CONFLICT_FILES; do
            if [ ! -f "$f" ]; then
              COMMENT="$COMMENT**$f**: (file missing in working tree)\\n\\n"
              continue
            fi

            filesize=$(wc -c < "$f" | tr -d ' ')
            if [ "$filesize" -le "$MAX_INLINE" ]; then
              CONTENT=$(sed -n '1,400000p' "$f" | sed 's/\r$//')
              # choose fence type to avoid nested triple backtick collisions
              if printf '%s' "$CONTENT" | grep -q '\`\`\`'; then
                fence="~~~"
              else
                fence="\`\`\`"
              fi
              COMMENT="$COMMENT**File: $f**\\n$fence\n$CONTENT\n$fence\\n\\n"
            else
              # create a private gist as fallback
              echo "Creating gist for large file $f" >&2
              GIST_PAYLOAD=$(jq -nc --arg name "$f" --arg content "$(sed -n '1,400000p' "$f")" '{public:false,files:{($name):{content:$content}}}')
              GIST_RESPONSE=$(curl -s -X POST -H "Authorization: token $REPO_PAT" -H "Content-Type: application/json" -d "$GIST_PAYLOAD" https://api.github.com/gists)
              GIST_URL=$(echo "$GIST_RESPONSE" | jq -r .html_url // empty)
              if [ -n "$GIST_URL" ]; then
                COMMENT="$COMMENT**File: $f**: $GIST_URL\\n\\n"
              else
                CONTENT=$(sed -n '1,400000p' "$f" | sed 's/\r$//')
                COMMENT="$COMMENT**File: $f** (failed to create gist; inlined)\\n\`\`\`text\n$CONTENT\n\`\`\`\\n\\n"
              fi
            fi
          done

          # detect PR number if not provided
          IN_PR="${{ github.event.inputs.pr_number || '' }}"
          PR="$IN_PR"
          if [ -z "$PR" ]; then
            echo "Attempting to find PR for branch ${BRANCH}" >&2
            # head format: owner:branch
            OWNER="${{ github.repository_owner }}"
            PR=$(curl -s -H "Authorization: token $REPO_PAT" "${GITHUB_API}/repos/${REPO}/pulls?head=${OWNER}:${BRANCH}" | jq -r '.[0].number // empty')
          fi

          if [ -z "$PR" ]; then
            echo "No PR found for branch ${BRANCH}. Will print prepared comment in logs and exit." >&2
            echo "prepared_comment<<EOF" >> $GITHUB_OUTPUT
            echo "$COMMENT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "pr_number=$PR" >> $GITHUB_OUTPUT
          echo "prepared_comment<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post comment to PR as REPO_PAT owner
        if: steps.attempt_merge.outputs.conflicts == 'true'
        env:
          REPO_PAT: ${{ secrets.REPO_PAT }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          PR="${{ steps.prepare.outputs.pr_number }}"
          COMMENT_BODY="${{ steps.prepare.outputs.prepared_comment }}"
          if [ -z "$PR" ]; then
            echo "PR not detected. Prepared comment (printed to logs):"
            echo "$COMMENT_BODY"
            exit 1
          fi

          echo "Posting comment to PR #$PR ..."
          PAYLOAD=$(jq -n --arg body "$COMMENT_BODY" '{body: $body}')
          POST_URL="https://api.github.com/repos/${REPO}/issues/${PR}/comments"
          RESPONSE=$(curl -s -X POST -H "Authorization: token $REPO_PAT" -H "Content-Type: application/json" -d "$PAYLOAD" "$POST_URL")
          echo "Comment URL: $(echo "$RESPONSE" | jq -r '.html_url // "no-url-returned"')"

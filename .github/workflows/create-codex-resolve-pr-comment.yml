name: Tell @codex to fix merge conflict
on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to attempt merging default branch into"
        required: true
      repo:
        description: "owner/repo (defaults to this repo)"
        required: false
        default: ""
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  post-conflicts:
    name: post-conflicts
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      issues: write
      
    env:
      GITHUB_API: https://api.github.com
      # REPO defaults to this repository unless provided via workflow_dispatch input
      REPO: ${{ github.event.inputs.repo != '' && github.event.inputs.repo || github.repository }}
      # BRANCH is the head branch of the PR, or the workflow_dispatch input
      BRANCH: ${{ github.event_name == 'pull_request' && github.head_ref || github.event.inputs.branch }}
      # Personal access token must have "gist" scope to create private gists
      REPO_PAT: ${{ secrets.REPO_PAT }}
      MAX_INLINE: "30000"  # bytes of inline context when gists are unavailable
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH }}
          fetch-depth: 0

      - name: Git identity
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Detect and dry-merge default branch
        id: merge_try
        shell: bash
        run: |
          set -euo pipefail
          echo "Repository: $REPO"
          echo "Branch:     $BRANCH"

          # Be explicit: fetch remote refs we may refer to
          git fetch origin main || true
          git fetch origin master || true

          echo "::group::Refs"
          git show-ref --head || true
          git branch -a || true
          echo "::endgroup::"

          set -e
          # Prefer origin/main, fallback to origin/master, fallback to FETCH_HEAD (from earlier fetch)
          MERGE_TARGET=""
          if git rev-parse --verify --quiet refs/remotes/origin/main >/dev/null; then
            MERGE_TARGET="origin/main"
          elif git rev-parse --verify --quiet refs/remotes/origin/master >/dev/null; then
            MERGE_TARGET="origin/master"
          else
            MERGE_TARGET="FETCH_HEAD"
          fi

          echo "merge_target=$MERGE_TARGET" >> "$GITHUB_OUTPUT"

          # Do a no-commit merge to expose conflicts in the index without creating history
          set +e
          git merge --no-commit --no-ff "$MERGE_TARGET"
          MERGE_CODE=$?
          set -e

          # If there are staged changes without conflicts (fast-forward or clean merge), we still treat as "no conflicts"
          if git ls-files -u | grep -q .; then
            echo "conflicts=true" >> "$GITHUB_OUTPUT"
          else
            echo "conflicts=false" >> "$GITHUB_OUTPUT"
            # Reset to clean state to avoid dirty workspace
            git merge --abort || git reset --hard
          fi

      - name: Prepare conflict comment (and create gists)
        if: steps.merge_try.outputs.conflicts == 'true'
        id: prep_comment
        shell: bash
        env:
          MAX_INLINE: ${{ env.MAX_INLINE }}
          REPO_PAT: ${{ env.REPO_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          emit_inline_reference() {
            local file_path="$1"
            local limit_bytes="$2"
            local file_content truncated fence

            if [[ -n "$limit_bytes" && "$limit_bytes" =~ ^[0-9]+$ && "$limit_bytes" -gt 0 ]]; then
              truncated=$(head -c "$limit_bytes" "$file_path")
            else
              truncated=$(head -c 30000 "$file_path")
            fi

            if [[ "$truncated" == *\`\`\`* ]]; then
              fence="~~~"
            else
              fence="\`\`\`"
            fi

            printf -- "- **%s** (inline, truncated)\n%s\n%s\n%s\n" \
              "$file_path" "$fence" "$truncated" "$fence"
          }

          USE_GISTS=1
          if [[ -z "${REPO_PAT:-}" ]]; then
            echo "REPO_PAT is not set; falling back to inline conflict content." >&2
            USE_GISTS=0
          fi

          CONFLICT_FILES=$(git ls-files -u | awk '{print $4}' | sort -u)
          echo "Conflicted files: $CONFLICT_FILES" >&2

          read -r -d '' PREAMBLE <<'TXT'
          Automated context: attempted merging the repository default branch into `'"$BRANCH"'` produced merge conflicts. Tagging @codex to resolve.

          ---
          **Resolution instructions for @codex (follow exactly):**

          ```text
          @codex You are resolving a Git merge conflict. I will provide the full file contents including conflict markers (<<<<<<<, =======, >>>>>>>).

          Your task:
              Combine both conflicting changes so that no functionality is lost.
              Prefer keeping new code from both branches unless it is clearly redundant or incompatible.
              Preserve function signatures, imports, and surrounding context exactly unless they must change for the code to run.
              Ensure the final code is syntactically correct and logically consistent.
              Do NOT remove new functionality from either branch unless it is duplicated.
              Resolve without adding comments, explanations, and be sure to remove conflict markers.

          After producing the resolved file(s), overwrite the conflicted file(s) in the branch, then run (from the repo root):
              git add <file> && git commit -m "chore: AI-resolved merge conflicts (automated)" && git push origin HEAD

          You should push using credentials that can push to this repository as the repository user.

          END OF INSTRUCTIONS.
          ```

          ---

          TXT

          GIST_LINES=""
          for f in $CONFLICT_FILES; do
            if [[ -f "$f" ]]; then
              # Read up to 400k lines (~large), normalize line endings
              FILE_CONTENT=$(sed -n '1,400000p' "$f" | sed 's/\r$//')

              if [[ "$USE_GISTS" -eq 1 ]]; then
                # Create a private gist with the exact file content
                GIST_PAYLOAD=$(jq -nc --arg name "$f" --arg content "$FILE_CONTENT" \
                  '{public:false, files:{($name):{content:$content}}}')

                set +e
                GIST_RESPONSE=$(curl -s -X POST \
                  -H "Authorization: token $REPO_PAT" \
                  -H "Content-Type: application/json" \
                  -d "$GIST_PAYLOAD" https://api.github.com/gists)
                CURL_STATUS=$?
                set -e

                if [[ $CURL_STATUS -eq 0 && -n "$GIST_RESPONSE" ]]; then
                  set +e
                  GIST_URL=$(printf '%s' "$GIST_RESPONSE" | jq -r '.html_url // empty')
                  JQ_STATUS=$?
                  set -e
                  if [[ $JQ_STATUS -eq 0 && -n "$GIST_URL" ]]; then
                    GIST_LINES+="- **$f**: ${GIST_URL}\n"
                    continue
                  fi
                fi

                if [[ $CURL_STATUS -ne 0 ]]; then
                  echo "Failed to create gist for $f (curl exit $CURL_STATUS); falling back to inline snippet." >&2
                else
                  echo "Failed to create gist for $f; falling back to inline snippet." >&2
                fi
              fi

              GIST_LINES+="$(emit_inline_reference "$f" "$MAX_INLINE")"
            else
              GIST_LINES+="- **$f**: (file missing in working tree)\n"
            fi
          done

          COMMENT_BODY="${PREAMBLE}**Conflicted files:**\n${GIST_LINES}"

          # Expose prepared body to later steps and logs
          {
            echo 'prepared_comment<<EOF'
            echo "$COMMENT_BODY"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Find PR number
        if: steps.merge_try.outputs.conflicts == 'true'
        id: find_pr
        shell: bash
        env:
          REPO_PAT: ${{ env.REPO_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # If we're in a PR run, we already have the number
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "pr_number=${{ github.event.number }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # workflow_dispatch path: look up PR by head branch
          OWNER="${REPO%%/*}"
          AUTH_TOKEN="${REPO_PAT:-${GITHUB_TOKEN:-}}"
          if [[ -z "$AUTH_TOKEN" ]]; then
            echo "No token available to query pull requests." >&2
            echo "pr_number=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          PR=$(curl -s -H "Authorization: token $AUTH_TOKEN" \
                "$GITHUB_API/repos/$REPO/pulls?head=${OWNER}:${BRANCH}" | jq -r '.[0].number // empty')
          if [[ -z "$PR" || "$PR" == "null" ]]; then
            echo "No PR found for $OWNER:$BRANCH" >&2
            echo "pr_number=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "pr_number=$PR" >> "$GITHUB_OUTPUT"

      - name: Post comment to PR
        if: steps.merge_try.outputs.conflicts == 'true' && steps.find_pr.outputs.pr_number != ''
        shell: bash
        run: |
          set -euo pipefail
          # Use the workflow GITHUB_TOKEN for repo comments
          jq -n --arg body "${{ steps.prep_comment.outputs.prepared_comment }}" '{body:$body}' | \
          curl -sS -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -d @- "${GITHUB_API}/repos/${REPO}/issues/${{ steps.find_pr.outputs.pr_number }}/comments" >/dev/null

      - name: Echo prepared comment (no PR found)
        if: steps.merge_try.outputs.conflicts == 'true' && (steps.find_pr.outputs.pr_number == '' || steps.find_pr.outcome == 'failure')
        shell: bash
        run: |
          echo "${{ steps.prep_comment.outputs.prepared_comment }}"

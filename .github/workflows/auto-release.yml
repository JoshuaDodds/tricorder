name: Auto release

on:
  push:
    branches:
      - main

env:
  INTEGRATION_BRANCH: staging

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Check merge source
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const integrationBranch = process.env.INTEGRATION_BRANCH;
            const headCommit = context.payload.head_commit;
            if (!headCommit) {
              core.info('No head commit information available. Skipping release.');
              core.setOutput('eligible', 'false');
              return;
            }
            const message = headCommit.message || '';
            const patterns = [
              new RegExp(`Merge pull request #\\d+.*\\/${integrationBranch}\\b`),
              new RegExp(`Merge branch ['\"]${integrationBranch}['\"]`),
              new RegExp(`Merge remote-tracking branch ['\"]origin\\/${integrationBranch}['\"]`)
            ];
            const eligible = patterns.some((pattern) => pattern.test(message));
            if (!eligible) {
              core.info(`Head commit message did not match integration branch merge patterns. Message: ${message}`);
            }
            core.setOutput('eligible', eligible ? 'true' : 'false');
      - name: Checkout
        if: steps.check.outputs.eligible == 'true'
        uses: actions/checkout@v4
      - name: Determine release version
        if: steps.check.outputs.eligible == 'true'
        id: version
        uses: actions/github-script@v7
        with:
          script: |
            const now = new Date();
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const prefix = `${year}.${month}.${day}.`;
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            let maxPatch = 0;
            for (const release of releases) {
              const candidate = release.tag_name || release.name || '';
              if (!candidate.startsWith(prefix)) {
                continue;
              }
              const patchPart = candidate.slice(prefix.length).trim();
              const patch = parseInt(patchPart, 10);
              if (!Number.isNaN(patch)) {
                maxPatch = Math.max(maxPatch, patch);
              }
            }
            const nextPatch = maxPatch + 1;
            const version = `${prefix}${nextPatch}`;
            core.setOutput('version', version);
      - name: Create release
        if: steps.check.outputs.eligible == 'true'
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.version.outputs.version }}
        with:
          script: |
            const version = process.env.VERSION;
            if (!version) {
              core.setFailed('Release version was not provided.');
              return;
            }
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: version,
              name: version,
              target_commitish: context.sha,
              generate_release_notes: true,
            });

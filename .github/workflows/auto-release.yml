name: Auto release

on:
  push:
    branches:
      - main

env:
  INTEGRATION_BRANCH: staging

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Check merge source
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const integrationBranch = process.env.INTEGRATION_BRANCH;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.sha;

            if (!integrationBranch) {
              core.setFailed('INTEGRATION_BRANCH env variable is not set.');
              return;
            }

            try {
              const branch = await github.rest.repos.getBranch({
                owner,
                repo,
                branch: integrationBranch,
              });

              const stagingSha = branch.data.commit.sha;

              if (sha === stagingSha) {
                core.setOutput('eligible', 'true');
                return;
              }

              const commit = await github.rest.repos.getCommit({
                owner,
                repo,
                ref: sha,
              });

              const parentShas = commit.data.parents.map((parent) => parent.sha);

              let eligible = false;

              if (parentShas.length >= 2) {
                for (const parentSha of parentShas) {
                  if (parentSha === stagingSha) {
                    eligible = true;
                    break;
                  }

                  try {
                    const comparison = await github.rest.repos.compareCommitsWithBasehead({
                      owner,
                      repo,
                      basehead: `${parentSha}...${integrationBranch}`,
                    });

                    const { status, behind_by: behindBy } = comparison.data;
                    const parentReachable = behindBy === 0 && status !== 'diverged';

                    if (parentReachable) {
                      eligible = true;
                      break;
                    }
                  } catch (compareError) {
                    core.info(
                      `Failed to compare ${integrationBranch} with parent ${parentSha}: ${compareError.message}`
                    );
                  }
                }

                if (!eligible) {
                  core.info(
                    `Head commit ${sha} parents ${parentShas.join(', ')} are not reachable from ${integrationBranch}.`
                  );
                }
              } else {
                core.info(
                  `Head commit ${sha} is not a merge commit (parents: ${parentShas.length}). Skipping release.`
                );
              }

              core.setOutput('eligible', eligible ? 'true' : 'false');
            } catch (error) {
              if (error.status === 404) {
                core.info(`Branch ${integrationBranch} not found. Skipping release.`);
                core.setOutput('eligible', 'false');
                return;
              }
              core.setFailed(`Failed to compare commits with ${integrationBranch}: ${error.message}`);
            }
      - name: Checkout
        if: steps.check.outputs.eligible == 'true'
        uses: actions/checkout@v4
      - name: Determine release version
        if: steps.check.outputs.eligible == 'true'
        id: version
        uses: actions/github-script@v7
        with:
          script: |
            const now = new Date();
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const prefix = `${year}.${month}.${day}.`;
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            let maxPatch = 0;
            for (const release of releases) {
              const candidate = release.tag_name || release.name || '';
              if (!candidate.startsWith(prefix)) {
                continue;
              }
              const patchPart = candidate.slice(prefix.length).trim();
              const patch = parseInt(patchPart, 10);
              if (!Number.isNaN(patch)) {
                maxPatch = Math.max(maxPatch, patch);
              }
            }
            const nextPatch = maxPatch + 1;
            const version = `${prefix}${nextPatch}`;
            core.setOutput('version', version);
      - name: Create release
        if: steps.check.outputs.eligible == 'true'
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.version.outputs.version }}
        with:
          script: |
            const version = process.env.VERSION;
            if (!version) {
              core.setFailed('Release version was not provided.');
              return;
            }
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: version,
              name: version,
              target_commitish: context.sha,
              generate_release_notes: true,
            });
